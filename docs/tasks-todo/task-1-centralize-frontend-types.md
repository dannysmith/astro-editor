# Centralize Frontend Types

**Priority**: MEDIUM (if time permits before 1.0.0, otherwise post-1.0.0)
**Effort**: ~0.5 day
**Type**: Code organization, maintainability, type safety

## Problem

Domain types like `FileEntry`, `Collection`, `CollectionSchema`, `Settings`, etc. are currently defined inline in multiple files throughout the codebase. This creates several issues:

1. **Type drift**: Different files may have slightly different definitions or subsets of the same type
2. **Import confusion**: Hard to know where the "canonical" type definition lives
3. **Maintenance burden**: Changing a type requires finding all definitions
4. **Inconsistent field naming**: Without a single source of truth, fields may be named differently
5. **Harder to reason about**: Domain model is scattered across many files

**Evidence from Domain Modeling Review** (⭐⭐⭐):
> "Main recommendation (centralize types) is good but non-urgent"

## Current State

**Example: FileEntry type appears in multiple places**:

```typescript
// src/store/editorStore.ts
interface FileEntry {
  id: string
  name: string
  path: string
  collection: string
  frontmatter: Record<string, unknown>
}

// src/components/layout/LeftSidebar.tsx
type FileEntry = {
  id: string
  name: string
  path: string
  frontmatter?: Record<string, any>
}

// src/hooks/useCollectionFiles.ts
interface FileEntry {
  id: string
  name: string
  path: string
  collection: string
  // ... more fields
}
```

**Issues**:
- Three different definitions
- `frontmatter` is optional in one, required in others
- Field types vary (`unknown` vs `any`)
- Missing fields in some definitions

## Benefits of Centralization

1. **Single source of truth**: One canonical definition for each domain type
2. **Better IDE support**: Go-to-definition jumps to actual type, not inline definition
3. **Easier refactoring**: Change once, apply everywhere
4. **Type safety**: Catch mismatches between components
5. **Documentation**: Central place to document domain model
6. **Onboarding**: New developers can learn domain model from one file

## Requirements

**Must Have**:
- [ ] Central `src/types/domain.ts` file created
- [ ] Core domain types defined: `FileEntry`, `Collection`, `CollectionSchema`, `Settings`, `Project`
- [ ] All inline type definitions replaced with imports
- [ ] No type errors introduced
- [ ] All existing functionality preserved

**Should Have**:
- [ ] JSDoc comments documenting each type and field
- [ ] Utility types for common patterns (e.g., `Partial<FileEntry>` for drafts)
- [ ] Type guards for runtime validation
- [ ] Clear exports from `src/types/index.ts`

**Nice to Have**:
- [ ] Diagram of type relationships
- [ ] Migration guide for adding new domain types
- [ ] Validation schemas (Zod) alongside TypeScript types

## Core Types to Centralize

### 1. FileEntry

```typescript
// src/types/domain.ts

/**
 * Represents a markdown file in an Astro content collection.
 * Files have frontmatter (parsed from YAML), content (markdown body),
 * and metadata (path, collection, etc.).
 */
export interface FileEntry {
  /** Unique identifier (typically relative path without extension) */
  id: string

  /** Display name (typically filename without extension) */
  name: string

  /** Absolute file path */
  path: string

  /** Collection this file belongs to */
  collection: string

  /** Parsed frontmatter data */
  frontmatter: Record<string, unknown>

  /** Markdown content (body) */
  content?: string

  /** File system metadata */
  metadata?: {
    created: string
    modified: string
    size: number
  }
}

/**
 * Partial file entry used when not all data is available.
 * Commonly used in file lists where content isn't loaded yet.
 */
export type PartialFileEntry = Pick<FileEntry, 'id' | 'name' | 'path' | 'collection'> & {
  frontmatter?: Partial<FileEntry['frontmatter']>
}

/**
 * Type guard to check if an object is a FileEntry
 */
export function isFileEntry(obj: unknown): obj is FileEntry {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'name' in obj &&
    'path' in obj &&
    'collection' in obj
  )
}
```

### 2. Collection

```typescript
/**
 * Represents an Astro content collection with its schema.
 * Collections are defined in src/content/config.ts and contain
 * markdown files with typed frontmatter.
 */
export interface Collection {
  /** Collection name (e.g., "posts", "docs") */
  name: string

  /** Human-readable label for UI */
  label?: string

  /** Parsed Zod schema for this collection's frontmatter */
  schema: CollectionSchema

  /** Number of files in this collection */
  fileCount?: number
}

/**
 * Parsed representation of a Zod schema.
 * Generated by Rust backend from Astro config.
 */
export interface CollectionSchema {
  /** Field name to field definition mapping */
  fields: Record<string, SchemaField>

  /** Required field names */
  required?: string[]
}

/**
 * Individual field in a collection schema.
 */
export interface SchemaField {
  /** Field type (string, number, boolean, date, array, object, enum, reference) */
  type: FieldType

  /** Is this field required? */
  required?: boolean

  /** Default value if not provided */
  default?: unknown

  /** For enum fields: allowed values */
  enum?: string[]

  /** For array fields: item type */
  items?: SchemaField

  /** For reference fields: target collection */
  collection?: string

  /** Description/help text for this field */
  description?: string
}

export type FieldType =
  | 'string'
  | 'number'
  | 'boolean'
  | 'date'
  | 'datetime'
  | 'array'
  | 'object'
  | 'enum'
  | 'reference'
  | 'image'
  | 'markdown'
```

### 3. Settings Types

```typescript
/**
 * Application settings (three-tier system: global, project, file)
 * See docs/developer/preferences-system.md for details.
 */
export interface Settings {
  general?: GeneralSettings
  editor?: EditorSettings
  appearance?: AppearanceSettings
}

export interface GeneralSettings {
  /** Default IDE command for "open in IDE" */
  ideCommand?: string

  /** Auto-save enabled? */
  autoSave?: boolean

  /** Auto-save delay in seconds */
  autoSaveDelay?: number
}

export interface EditorSettings {
  /** Font family for editor */
  fontFamily?: string

  /** Font size in pixels */
  fontSize?: number

  /** Line height multiplier */
  lineHeight?: number

  /** Show line numbers? */
  showLineNumbers?: boolean

  /** Wrap lines? */
  wordWrap?: boolean

  /** Tab size in spaces */
  tabSize?: number
}

export interface AppearanceSettings {
  /** Theme: light, dark, or auto */
  theme?: 'light' | 'dark' | 'auto'

  /** Sidebar position: left or right */
  sidebarPosition?: 'left' | 'right'

  /** Show drafts in file list? */
  showDrafts?: boolean
}
```

### 4. Project Type

```typescript
/**
 * Represents an Astro project opened in the editor.
 */
export interface Project {
  /** Absolute path to project root */
  path: string

  /** Project name (typically directory name) */
  name: string

  /** Collections discovered in this project */
  collections: Collection[]

  /** Project-level settings (override global) */
  settings?: Settings
}
```

### 5. UI State Types

```typescript
/**
 * UI state types (not persisted, just runtime state)
 */

export interface EditorState {
  /** Currently open file */
  currentFile: FileEntry | null

  /** Current editor content */
  editorContent: string

  /** Current frontmatter */
  frontmatter: Record<string, unknown>

  /** Has unsaved changes? */
  isDirty: boolean

  /** Save in progress? */
  isSaving: boolean
}

export interface UIState {
  /** Sidebar collapsed state */
  sidebarCollapsed: boolean

  /** Frontmatter panel collapsed state */
  frontmatterCollapsed: boolean

  /** Sidebar width in pixels */
  sidebarWidth: number

  /** Frontmatter panel width in pixels */
  frontmatterWidth: number

  /** Command palette open? */
  commandPaletteOpen: boolean
}
```

## Implementation Plan

### Phase 1: Create Central Types File

1. Create `src/types/domain.ts`
2. Define all core types with JSDoc comments
3. Add type guards and utility types
4. Create `src/types/index.ts` with re-exports

```typescript
// src/types/index.ts
export type {
  FileEntry,
  PartialFileEntry,
  Collection,
  CollectionSchema,
  SchemaField,
  FieldType,
  Settings,
  GeneralSettings,
  EditorSettings,
  AppearanceSettings,
  Project,
  EditorState,
  UIState,
} from './domain'

export { isFileEntry, isCollection } from './domain'
```

### Phase 2: Update Imports Gradually

**Strategy**: Replace type definitions file-by-file to minimize breakage

1. **Start with stores** (most critical):
   - `src/store/editorStore.ts`
   - `src/store/projectStore.ts`
   - `src/store/uiStore.ts`

2. **Update hooks**:
   - `src/hooks/useCollections.ts`
   - `src/hooks/useCollectionFiles.ts`
   - `src/hooks/useFileContent.ts`

3. **Update components**:
   - `src/components/layout/`
   - `src/components/frontmatter/`
   - `src/components/editor/`

4. **Update lib/**:
   - `src/lib/query-keys.ts`
   - `src/lib/schema.ts`
   - `src/lib/commands/`

### Phase 3: Remove Duplicate Definitions

Use TypeScript compiler to find remaining inline definitions:

```bash
# Search for inline type definitions
pnpm run tsc --noEmit --listFiles | grep -E "(interface|type) (FileEntry|Collection)"
```

Remove duplicates and replace with imports:

```typescript
// Before
interface FileEntry {
  id: string
  name: string
  // ...
}

// After
import type { FileEntry } from '@/types'
```

### Phase 4: Validation

1. Run TypeScript compiler: `pnpm run type-check`
2. Run all tests: `pnpm run test`
3. Run linter: `pnpm run lint`
4. Manual smoke test: Open project, edit file, save

## Success Criteria

- [ ] `src/types/domain.ts` created with all core types
- [ ] `src/types/index.ts` created with clean exports
- [ ] All stores import types from central location
- [ ] All hooks import types from central location
- [ ] All components import types from central location
- [ ] No inline type definitions for core domain types
- [ ] TypeScript compilation succeeds with no errors
- [ ] All tests pass
- [ ] No functionality broken
- [ ] JSDoc comments on all exported types

## Risks and Mitigations

### Risk 1: Breaking Changes

**Risk**: Centralizing types might reveal mismatches that break code

**Mitigation**:
- Do this incrementally, file by file
- Run TypeScript compiler after each change
- Keep old inline types alongside imports temporarily
- Test thoroughly before committing

### Risk 2: Import Cycles

**Risk**: Central types file might create circular dependencies

**Mitigation**:
- Keep `types/` pure (no imports from other app code)
- Only define data structures, no logic
- Use type-only imports: `import type { ... }`

### Risk 3: Merge Conflicts

**Risk**: Touching many files increases merge conflict likelihood

**Mitigation**:
- Do this in a single focused PR
- Avoid mixing with other changes
- Communicate with team (N/A for solo project)

## Out of Scope

- Runtime validation (Zod schemas) - could be added later
- API response types - keep in query hooks for now
- Component prop types - those are fine inline
- Tauri command types - those mirror Rust types

## References

- Domain Modeling Review: `docs/reviews/domain-modeling-review-2025-10-24.md`
- Meta-analysis: `docs/reviews/analyysis-of-reviews.md` (Week 2, item #6)
- Current type usage: Search codebase for `interface FileEntry`, `type Collection`, etc.
- TypeScript Handbook: https://www.typescriptlang.org/docs/handbook/2/everyday-types.html

## Dependencies

**Blocks**: None
**Blocked by**: None
**Related**: All tasks that touch TypeScript code

## Recommendation

**Do this in Week 2 if time permits, or defer to 1.1.0**. This is pure code organization with no user-facing impact. It improves maintainability but doesn't fix any bugs or risks.

**Estimated effort**:
- Create central types file: 1 hour
- Update stores and hooks: 1 hour
- Update components: 1.5 hours
- Remove duplicates and validate: 0.5 hours
- **Total: 4 hours (half day)**

**ROI**: Medium - improves maintainability and onboarding, but not critical for 1.0.0
