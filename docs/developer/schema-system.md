# Schema Parsing and Merging System

This guide covers the Rust-based schema parsing and merging architecture that powers the dynamic frontmatter form generation.

## Table of Contents

- [Overview](#overview)
- [Schema Sources](#schema-sources)
- [Schema Merging Process](#schema-merging-process)
- [Frontend Deserialization](#frontend-deserialization)
- [Field Type System](#field-type-system)
- [Implementation Details](#implementation-details)

## Overview

**Key Principle**: All schema parsing and merging happens in the Rust backend (`src-tauri/src/schema_merger.rs`). The frontend receives only the merged result and deserializes it.

**Why Rust?**

- **Performance**: Parsing and merging happens once per collection, cached in memory
- **Type Safety**: Rust's type system ensures correct parsing
- **Single Source of Truth**: One implementation for all platforms
- **Error Handling**: Robust error handling with detailed messages

## Schema Sources

The system combines two complementary schema sources to build a complete field definition.

### 1. Astro JSON Schemas

**Location**: `.astro/collections/*.schema.json`

**Generated by**: `astro sync` command

**Provides**:
- Comprehensive type information
- Field constraints (min, max, minLength, maxLength, pattern)
- Field descriptions and documentation
- Default values
- Enum options
- Required field information

üìñ **For comprehensive details on Astro's JSON schema generation, see [astro-generated-contentcollection-schemas.md](./astro-generated-contentcollection-schemas.md)**

**Parsed by**: `parse_json_schema()` in `src-tauri/src/schema_merger.rs`

### 2. Zod Schemas

**Location**: `src/content/config.ts`

**Format**: TypeScript with Zod schema definitions

**Provides**:
- Reference information (`z.reference('authors')`) for dropdown fields
- Additional validation rules
- Collection configuration

**Example**:

```typescript
import { defineCollection, z } from 'astro:content'

const blog = defineCollection({
  type: 'content',
  schema: z.object({
    title: z.string().min(3).max(100),
    publishDate: z.date(),
    author: z.reference('authors'), // ‚Üê Reference for dropdown
    draft: z.boolean().default(false),
    tags: z.array(z.string()).optional(),
  }),
})

export const collections = { blog }
```

**Parsed by**: Regex-based parsing in `parser.rs`
- `extract_collections_block()`: Extracts the collections export
- `parse_simple_config()`: Parses individual collection schemas

## Schema Merging Process

The `create_complete_schema()` function merges both sources into a unified `CompleteSchema`.

### Merge Algorithm

```rust
pub fn create_complete_schema(
    json_schema_path: &Path,
    zod_schema_path: &Path,
    collection_name: &str,
) -> Result<CompleteSchema, String> {
    // 1. Parse JSON schema (primary source)
    let json_schema = parse_json_schema(json_schema_path)?;

    // 2. Parse Zod schema (supplementary)
    let zod_schema = parse_zod_schema(zod_schema_path, collection_name)?;

    // 3. Merge: JSON schema as base, Zod adds references
    let mut merged_fields = HashMap::new();

    for (field_name, json_field) in json_schema.fields {
        let mut field = json_field;

        // Add reference from Zod if present
        if let Some(zod_field) = zod_schema.fields.get(&field_name) {
            if let Some(reference) = &zod_field.reference {
                field.reference = Some(reference.clone());
            }
        }

        merged_fields.insert(field_name, field);
    }

    Ok(CompleteSchema {
        collection_name: collection_name.to_string(),
        fields: merged_fields,
        required: json_schema.required,
    })
}
```

### Merge Strategy

**JSON Schema** (Primary):
- Provides base field type
- Sets constraints
- Defines defaults
- Specifies required fields

**Zod Schema** (Supplementary):
- Adds reference information
- May override or supplement validation

**Result**: A complete field definition with:
```rust
pub struct SchemaField {
    pub field_type: FieldType,
    pub description: Option<String>,
    pub default: Option<serde_json::Value>,
    pub required: bool,
    pub constraints: Option<FieldConstraints>,
    pub reference: Option<String>,  // From Zod
    pub enum_values: Option<Vec<String>>,
}
```

## Frontend Deserialization

The frontend receives the merged schema as a JSON string and deserializes it.

### Rust Serialization

```rust
// In Tauri command
#[tauri::command]
pub async fn get_collections(project_path: String) -> Result<Vec<CollectionInfo>, String> {
    let collections = discover_collections(&project_path)?;

    let mut result = Vec::new();
    for collection in collections {
        let schema = create_complete_schema(
            &collection.json_schema_path,
            &collection.zod_schema_path,
            &collection.name,
        )?;

        // Serialize to JSON string
        let schema_json = serde_json::to_string(&schema)
            .map_err(|e| format!("Failed to serialize schema: {}", e))?;

        result.push(CollectionInfo {
            name: collection.name,
            complete_schema: schema_json,  // ‚Üê Serialized schema
        });
    }

    Ok(result)
}
```

### Frontend Deserialization

```typescript
// src/lib/schema.ts
export function deserializeCompleteSchema(
  schemaJson: string
): CompleteSchema {
  const parsed = JSON.parse(schemaJson)

  return {
    collectionName: parsed.collection_name,
    fields: new Map(Object.entries(parsed.fields)),
    required: parsed.required || [],
  }
}
```

**Important**: The frontend does NOT parse schemas. It only deserializes the pre-merged JSON structure from Rust.

## Field Type System

### FieldType Enum

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum FieldType {
    String,
    Number,
    Integer,
    Boolean,
    Date,
    Array,
    Enum,
    Object,
    Reference,  // Special type for z.reference()
}
```

### Field Constraints

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FieldConstraints {
    pub min: Option<f64>,
    pub max: Option<f64>,
    pub min_length: Option<usize>,
    pub max_length: Option<usize>,
    pub pattern: Option<String>,
}
```

### Complete Schema Structure

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompleteSchema {
    pub collection_name: String,
    pub fields: HashMap<String, SchemaField>,
    pub required: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchemaField {
    pub field_type: FieldType,
    pub description: Option<String>,
    pub default: Option<serde_json::Value>,
    pub required: bool,
    pub constraints: Option<FieldConstraints>,
    pub reference: Option<String>,
    pub enum_values: Option<Vec<String>>,
    pub format: Option<String>,  // e.g., "date", "email", "textarea"
}
```

## Implementation Details

### JSON Schema Parsing

Located in `src-tauri/src/schema_merger.rs`:

```rust
fn parse_json_schema(path: &Path) -> Result<JsonSchema, String> {
    let content = fs::read_to_string(path)
        .map_err(|e| format!("Failed to read JSON schema: {}", e))?;

    let schema_value: serde_json::Value = serde_json::from_str(&content)
        .map_err(|e| format!("Failed to parse JSON schema: {}", e))?;

    // Extract properties
    let properties = schema_value["properties"]
        .as_object()
        .ok_or("Missing properties in schema")?;

    let mut fields = HashMap::new();

    for (field_name, field_value) in properties {
        let field = parse_json_field(field_value)?;
        fields.insert(field_name.clone(), field);
    }

    // Extract required fields
    let required = schema_value["required"]
        .as_array()
        .map(|arr| {
            arr.iter()
                .filter_map(|v| v.as_str().map(String::from))
                .collect()
        })
        .unwrap_or_default();

    Ok(JsonSchema { fields, required })
}

fn parse_json_field(value: &serde_json::Value) -> Result<SchemaField, String> {
    let field_type = match value["type"].as_str() {
        Some("string") => {
            if value["format"].as_str() == Some("date") {
                FieldType::Date
            } else {
                FieldType::String
            }
        }
        Some("number") => FieldType::Number,
        Some("integer") => FieldType::Integer,
        Some("boolean") => FieldType::Boolean,
        Some("array") => FieldType::Array,
        Some("object") => FieldType::Object,
        _ => return Err("Unknown field type".to_string()),
    };

    // Extract constraints
    let constraints = if value.get("minLength").is_some()
        || value.get("maxLength").is_some()
        || value.get("minimum").is_some()
        || value.get("maximum").is_some()
        || value.get("pattern").is_some()
    {
        Some(FieldConstraints {
            min_length: value["minLength"].as_u64().map(|v| v as usize),
            max_length: value["maxLength"].as_u64().map(|v| v as usize),
            min: value["minimum"].as_f64(),
            max: value["maximum"].as_f64(),
            pattern: value["pattern"].as_str().map(String::from),
        })
    } else {
        None
    };

    // Extract enum values
    let enum_values = value["enum"]
        .as_array()
        .map(|arr| {
            arr.iter()
                .filter_map(|v| v.as_str().map(String::from))
                .collect()
        });

    Ok(SchemaField {
        field_type,
        description: value["description"].as_str().map(String::from),
        default: value.get("default").cloned(),
        required: false, // Set by schema.required array
        constraints,
        reference: None, // Added from Zod schema
        enum_values,
        format: value["format"].as_str().map(String::from),
    })
}
```

### Zod Schema Parsing

Located in `src-tauri/src/parser.rs`:

```rust
pub fn parse_zod_schema(
    path: &Path,
    collection_name: &str,
) -> Result<ZodSchema, String> {
    let content = fs::read_to_string(path)
        .map_err(|e| format!("Failed to read Zod schema: {}", e))?;

    // Extract collections block
    let collections_block = extract_collections_block(&content)?;

    // Parse specific collection
    parse_simple_config(&collections_block, collection_name)
}

fn extract_collections_block(content: &str) -> Result<String, String> {
    // Find: export const collections = { ... }
    let re = regex::Regex::new(r"export\s+const\s+collections\s*=\s*(\{[^}]*\})")
        .map_err(|e| format!("Regex error: {}", e))?;

    let captures = re.captures(content)
        .ok_or("Could not find collections export")?;

    Ok(captures[1].to_string())
}

fn parse_simple_config(
    block: &str,
    collection_name: &str,
) -> Result<ZodSchema, String> {
    // Look for collection definition
    let pattern = format!(r"{}\s*:\s*defineCollection", collection_name);
    let re = regex::Regex::new(&pattern)
        .map_err(|e| format!("Regex error: {}", e))?;

    if !re.is_match(block) {
        return Err(format!("Collection '{}' not found", collection_name));
    }

    // Extract schema fields with z.reference()
    let ref_re = regex::Regex::new(r"(\w+)\s*:\s*z\.reference\(['\"](\w+)['\"]\)")
        .map_err(|e| format!("Regex error: {}", e))?;

    let mut fields = HashMap::new();

    for captures in ref_re.captures_iter(block) {
        let field_name = captures[1].to_string();
        let reference = captures[2].to_string();

        fields.insert(
            field_name,
            ZodField {
                reference: Some(reference),
            },
        );
    }

    Ok(ZodSchema { fields })
}
```

### Frontend Schema Access

```typescript
// src/hooks/queries/useCollectionsQuery.ts
export const useCollectionsQuery = (projectPath: string | null) => {
  return useQuery({
    queryKey: queryKeys.collections(projectPath || ''),
    queryFn: async () => {
      const collections = await invoke<CollectionInfo[]>('get_collections', {
        projectPath,
      })

      // Deserialize schemas
      return collections.map(col => ({
        ...col,
        schema: deserializeCompleteSchema(col.complete_schema),
      }))
    },
    enabled: !!projectPath,
  })
}

// In components
const { data: collections } = useCollectionsQuery(projectPath)
const blogCollection = collections?.find(c => c.name === 'blog')
const titleField = blogCollection?.schema.fields.get('title')

// titleField now has:
// - type (from JSON schema)
// - description (from JSON schema)
// - constraints (from JSON schema)
// - default (from JSON schema)
// - reference (from Zod schema)
```

## Benefits of This Architecture

1. **Single Source of Truth**: Schema parsing logic lives in one place (Rust)
2. **Performance**: Parsing happens once, results are cached
3. **Type Safety**: Rust ensures correct parsing and merging
4. **Simplicity**: Frontend just deserializes, doesn't parse
5. **Extensibility**: Easy to add new field types or constraints
6. **Reliability**: Rust's error handling ensures robustness

## Common Patterns

### Adding a New Field Type

1. **Add to FieldType enum** (Rust):

```rust
pub enum FieldType {
    // ... existing types
    Email,  // New type
}
```

2. **Update JSON parser** to recognize it:

```rust
let field_type = match value["type"].as_str() {
    Some("string") => {
        if value["format"].as_str() == Some("email") {
            FieldType::Email  // New handling
        } else {
            FieldType::String
        }
    }
    // ...
};
```

3. **Create field component** (TypeScript):

```typescript
const EmailField: React.FC<EmailFieldProps> = ({ name, label, required, field }) => {
  // Component implementation
}
```

4. **Update orchestrator** (`FrontmatterField.tsx`):

```typescript
if (field?.type === 'email') {
  return <EmailField name={name} label={label} required={required} field={field} />
}
```

### Debugging Schema Issues

**Enable debug logging** in Rust:

```rust
#[tauri::command]
pub async fn get_collections(project_path: String) -> Result<Vec<CollectionInfo>, String> {
    let schema = create_complete_schema(...)?;

    // Debug print
    println!("Schema for {}: {:#?}", collection.name, schema);

    // ...
}
```

**Check schema in frontend**:

```typescript
const { data: collections } = useCollectionsQuery(projectPath)
console.log('Collections:', collections)
console.log('Blog schema:', collections?.find(c => c.name === 'blog')?.schema)
```

---

**Remember**: All schema parsing and merging happens in Rust. The frontend only deserializes the pre-merged result. Never try to parse schemas in TypeScript.
