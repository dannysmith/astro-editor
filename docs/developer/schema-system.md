# Schema Parsing and Merging System

This guide covers the Rust-based schema parsing and merging architecture that powers the dynamic frontmatter form generation.

## Table of Contents

- [Overview](#overview)
- [Schema Sources](#schema-sources)
- [Schema Merging Process](#schema-merging-process)
- [How to Add New Astro Helpers](#how-to-add-new-astro-helpers)
- [Frontend Deserialization](#frontend-deserialization)
- [Implementation Reference](#implementation-reference)

## Overview

**Architecture Principle**: JSON schemas are the primary source of truth. The Zod parser enhances JSON schemas by identifying Astro-specific helpers.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   JSON Schema   ‚îÇ         ‚îÇ   Zod Parser     ‚îÇ
‚îÇ   (PRIMARY)     ‚îÇ         ‚îÇ  (ENHANCEMENT)   ‚îÇ
‚îÇ                 ‚îÇ         ‚îÇ                  ‚îÇ
‚îÇ ‚Ä¢ All fields    ‚îÇ         ‚îÇ ‚Ä¢ image() only   ‚îÇ
‚îÇ ‚Ä¢ Types         ‚îÇ         ‚îÇ ‚Ä¢ reference()    ‚îÇ
‚îÇ ‚Ä¢ Constraints   ‚îÇ    +    ‚îÇ                  ‚îÇ
‚îÇ ‚Ä¢ Descriptions  ‚îÇ         ‚îÇ                  ‚îÇ
‚îÇ ‚Ä¢ Defaults      ‚îÇ         ‚îÇ                  ‚îÇ
‚îÇ ‚Ä¢ Required      ‚îÇ         ‚îÇ                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                           ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚ñº
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ  Schema Merger   ‚îÇ
          ‚îÇ   (Rust)         ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚ñº
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ Complete Schema  ‚îÇ
          ‚îÇ   (JSON)         ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Why This Architecture?**

- **JSON Schema**: Generated by `astro sync`, contains comprehensive field information
- **Zod Parser**: Finds Astro helpers (`image()`, `reference()`) that JSON schema can't express
- **Rust Merging**: Single source of truth, type-safe, performant
- **Frontend**: Receives pre-merged schemas, just deserializes

## Schema Sources

### 1. JSON Schema (Primary Source)

**Location**: `.astro/collections/*.schema.json`

**Generated by**: `astro sync` command

**Provides**: All field information including:
- Field types (string, number, boolean, date, array, object, enum)
- Constraints (min, max, minLength, maxLength, pattern)
- Descriptions and documentation
- Default values
- Enum options
- Required field list
- Nested object structures (flattened with dotted paths: `coverImage.image`)

**Example Output**:
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "title": {
      "type": "string",
      "description": "Post title",
      "minLength": 3,
      "maxLength": 100
    },
    "coverImage.image": {
      "type": "string",
      "description": "Cover image path"
    },
    "author": {
      "type": "string",
      "description": "Author reference"
    }
  },
  "required": ["title"]
}
```

**Parsed by**: `parse_json_schema()` in `src-tauri/src/schema_merger.rs`

üìñ **For comprehensive details on Astro's JSON schema generation, see [astro-generated-conentcollection-schemas.md](./astro-generated-conentcollection-schemas.md)**

### 2. Zod Schema (Enhancement Source)

**Location**: `src/content/config.ts`

**Purpose**: Find Astro-specific helpers that JSON schema cannot express

**Currently Detects**:
- `image()` - Marks fields as image upload fields
- `reference('collection')` - Marks fields as dropdown references to other collections

**Example**:
```typescript
import { defineCollection, z, reference } from 'astro:content'

const blog = defineCollection({
  type: 'content',
  schema: ({ image }) => z.object({
    title: z.string().min(3).max(100),
    cover: image(),                      // ‚Üê Detected by Zod parser
    author: reference('authors'),         // ‚Üê Detected by Zod parser
    tags: z.array(reference('tags')),     // ‚Üê Detected by Zod parser
    coverImage: z.object({
      image: image().optional(),          // ‚Üê Nested, detected as "coverImage.image"
      alt: z.string().optional(),
    }).optional(),
  }),
})
```

**Output from Zod Parser** (JSON format):
```json
{
  "type": "zod",
  "fields": [
    {
      "name": "cover",
      "type": "Image",
      "optional": true,
      "default": null,
      "constraints": {}
    },
    {
      "name": "author",
      "type": "Reference",
      "optional": true,
      "default": null,
      "constraints": {},
      "referencedCollection": "authors"
    },
    {
      "name": "coverImage.image",
      "type": "Image",
      "optional": true,
      "default": null,
      "constraints": {}
    }
  ]
}
```

**Parsed by**: `find_helper_calls()` and `extract_zod_special_fields()` in `src-tauri/src/parser.rs`

## Schema Merging Process

The merging happens in `create_complete_schema()` in `schema_merger.rs`:

### Step 1: Parse JSON Schema (Primary)

```rust
// Parse JSON schema - this is the foundation
let mut schema = parse_json_schema(collection_name, json_schema)?;

// schema now contains ALL fields with their complete definitions
```

### Step 2: Extract Zod Enhancements

```rust
// Parse Zod schema and extract ONLY image() and reference() helpers
let (reference_map, image_fields) = extract_zod_enhancements(zod_schema)?;

// reference_map: Map<field_name, collection_name>
// image_fields: Set<field_name>
```

### Step 3: Apply Enhancements

```rust
for field in &mut schema.fields {
    // Apply reference collection names
    if let Some(collection_name) = reference_map.get(&field.name) {
        field.sub_type = Some("Reference".to_string());
        field.reference_collection = Some(collection_name.clone());
    }

    // Mark image fields
    if image_fields.contains(&field.name) {
        field.sub_type = Some("Image".to_string());
    }
}
```

### Result

A complete schema where:
- **ALL field information** comes from JSON schema (types, constraints, descriptions, etc.)
- **Special Astro helpers** are identified and marked by Zod parser
- **Frontend** receives a single, complete schema with everything it needs

## How to Add New Astro Helpers

Future Astro versions may introduce new helpers (e.g., `video()`, `file()`, `richText()`). Here's the pattern to add support:

### 1. Add Helper Detection (parser.rs)

Update `find_helper_calls()` to recognize the new helper:

```rust
fn find_helper_calls(schema_text: &str) -> Vec<HelperMatch> {
    let mut matches = Vec::new();

    // Existing: Find image() calls
    let image_re = Regex::new(r"image\s*\(\s*\)").unwrap();
    // ... existing code ...

    // NEW: Find video() calls
    let video_re = Regex::new(r"video\s*\(\s*\)").unwrap();
    for video_match in video_re.find_iter(schema_text) {
        matches.push(HelperMatch {
            helper_type: HelperType::Video,  // New enum variant
            position: video_match.start(),
            collection_name: None,
        });
    }

    matches
}
```

Add to `HelperType` enum:

```rust
#[derive(Debug, Clone, PartialEq)]
enum HelperType {
    Image,
    Reference,
    Video,  // NEW
}
```

### 2. Output in JSON Format (parser.rs)

Update `extract_zod_special_fields()` to output the new type:

```rust
let field_json = match helper.helper_type {
    HelperType::Image => {
        serde_json::json!({
            "name": field_path,
            "type": "Image",
            // ...
        })
    }
    HelperType::Video => {  // NEW
        serde_json::json!({
            "name": field_path,
            "type": "Video",
            // ...
        })
    }
    // ... other cases
};
```

### 3. Extract Enhancement (schema_merger.rs)

Update `extract_zod_enhancements()` to extract the new helper:

```rust
fn extract_zod_enhancements(
    zod_schema: &str,
) -> Result<(IndexMap<String, String>, HashSet<String>, HashSet<String>), String> {
    // ... existing code ...

    let mut video_fields = HashSet::new();  // NEW

    for field in schema.fields {
        // ... existing image and reference handling ...

        // NEW: Video field detection
        if field.type_ == "Video"
            || (field.type_ == "Array" && field.array_type.as_deref() == Some("Video"))
        {
            video_fields.insert(field.name);
        }
    }

    Ok((reference_map, image_fields, video_fields))
}
```

### 4. Apply to Schema Fields (schema_merger.rs)

Update `create_complete_schema()` to apply the new enhancement:

```rust
let (reference_map, image_fields, video_fields) = extract_zod_enhancements(zod_schema)?;

for field in &mut schema.fields {
    // ... existing enhancements ...

    // NEW: Mark video fields
    if video_fields.contains(&field.name) {
        field.sub_type = Some("Video".to_string());
    }
}
```

### 5. Handle in Frontend

Create a component for the new field type:

```typescript
// src/components/frontmatter/fields/VideoField.tsx
export const VideoField = ({ name, label, required, field }: VideoFieldProps) => {
  // Component implementation
}
```

Update `FrontmatterField.tsx` orchestrator:

```typescript
if (field?.subType === 'Video') {
  return <VideoField name={name} label={label} required={required} field={field} />
}
```

**Pattern Summary**:
1. **Detect** the helper in parser.rs using regex
2. **Output** it in JSON format from parser.rs
3. **Extract** it in schema_merger.rs
4. **Apply** it to JSON schema fields
5. **Render** it in the frontend

## Frontend Deserialization

The frontend receives the merged schema as JSON and deserializes it:

```typescript
// src/lib/schema.ts
export function deserializeCompleteSchema(schemaJson: string): CompleteSchema {
  const parsed = JSON.parse(schemaJson)

  return {
    collectionName: parsed.collection_name,
    fields: new Map(Object.entries(parsed.fields)),
    required: parsed.required || [],
  }
}
```

**Usage**:

```typescript
// In React Query hook
const collections = await invoke<CollectionInfo[]>('get_collections', { projectPath })

return collections.map(col => ({
  ...col,
  schema: deserializeCompleteSchema(col.complete_schema),
}))
```

**Important**: The frontend does NOT parse schemas. It only deserializes the pre-merged JSON structure from Rust.

## Implementation Reference

### File Locations

**Rust Backend**:
- `src-tauri/src/schema_merger.rs` - JSON schema parsing, Zod enhancement extraction, merging
- `src-tauri/src/parser.rs` - Zod helper detection (image, reference)
- `src-tauri/src/models/schema.rs` - Schema type definitions

**Frontend**:
- `src/lib/schema.ts` - Schema deserialization
- `src/components/frontmatter/FrontmatterField.tsx` - Field type orchestrator
- `src/components/frontmatter/fields/*` - Individual field components

### Key Functions

**parser.rs**:
- `find_helper_calls()` - Pattern matching to find `image()` and `reference()` helpers
- `resolve_field_path()` - Builds dotted paths for nested fields (e.g., `coverImage.image`)
- `extract_zod_special_fields()` - Main function that outputs JSON with detected helpers

**schema_merger.rs**:
- `parse_json_schema()` - Parses Astro JSON schema (primary source)
- `extract_zod_enhancements()` - Extracts helper field lists from Zod parser output
- `create_complete_schema()` - Merges JSON schema with Zod enhancements

### Data Flow

```
1. Astro Project
   ‚îî‚îÄ> src/content/config.ts (Zod schema)
   ‚îî‚îÄ> .astro/collections/*.schema.json (JSON schema)

2. Parser (parser.rs)
   ‚îî‚îÄ> Scans config.ts for image() and reference()
   ‚îî‚îÄ> Outputs JSON: { "fields": [{ "name": "cover", "type": "Image" }] }

3. Schema Merger (schema_merger.rs)
   ‚îî‚îÄ> Reads JSON schema (all field info)
   ‚îî‚îÄ> Extracts Zod enhancements (image/reference fields)
   ‚îî‚îÄ> Merges: marks appropriate fields with sub_type

4. Tauri Command
   ‚îî‚îÄ> Serializes merged schema to JSON string
   ‚îî‚îÄ> Sends to frontend

5. Frontend
   ‚îî‚îÄ> Deserializes JSON string
   ‚îî‚îÄ> Renders appropriate field components
```

## Benefits

1. **Separation of Concerns**: JSON schema for structure, Zod parser for Astro helpers
2. **Single Source of Truth**: Schema parsing in Rust only
3. **Extensibility**: Clear pattern for adding new helpers
4. **Performance**: Parsing happens once, results cached
5. **Type Safety**: Rust ensures correct parsing and merging
6. **Simplicity**: Frontend just deserializes, never parses

---

**Remember**: JSON schema is primary, Zod parser enhances. All parsing and merging happens in Rust. The frontend only deserializes the merged result.
