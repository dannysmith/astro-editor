// @ts-nocheck
/* eslint-disable */
// Auto-generated by tauri-specta. DO NOT EDIT.


// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async greet(name: string) : Promise<string> {
    return await TAURI_INVOKE("greet", { name });
},
async updateFormatMenuState(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_format_menu_state", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async readFile(filePath: string, projectRoot: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_file", { filePath, projectRoot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async writeFile(filePath: string, content: string, projectRoot: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("write_file", { filePath, content, projectRoot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createFile(directory: string, filename: string, content: string, projectRoot: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_file", { directory, filename, content, projectRoot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteFile(filePath: string, projectRoot: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_file", { filePath, projectRoot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async renameFile(oldPath: string, newPath: string, projectRoot: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("rename_file", { oldPath, newPath, projectRoot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async copyFileToAssets(sourcePath: string, projectPath: string, collection: string, currentFilePath: string, useRelativePaths: boolean) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("copy_file_to_assets", { sourcePath, projectPath, collection, currentFilePath, useRelativePaths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async copyFileToAssetsWithOverride(sourcePath: string, projectPath: string, collection: string, assetsDirectory: string | null, currentFilePath: string, useRelativePaths: boolean) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("copy_file_to_assets_with_override", { sourcePath, projectPath, collection, assetsDirectory, currentFilePath, useRelativePaths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async parseMarkdownContent(filePath: string, projectRoot: string) : Promise<Result<MarkdownContent, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("parse_markdown_content", { filePath, projectRoot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateFrontmatter(filePath: string, frontmatter: Partial<{ [key in string]: JsonValue }>, projectRoot: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_frontmatter", { filePath, frontmatter, projectRoot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveMarkdownContent(filePath: string, frontmatter: Partial<{ [key in string]: JsonValue }> | null, rawFrontmatter: string | null, content: string, imports: string, schemaFieldOrder: string[] | null, projectRoot: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_markdown_content", { filePath, frontmatter, rawFrontmatter, content, imports, schemaFieldOrder, projectRoot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveRecoveryData(data: JsonValue) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_recovery_data", { data }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveCrashReport(report: JsonValue) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_crash_report", { report }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAppDataDir() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_data_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async writeAppDataFile(filePath: string, content: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("write_app_data_file", { filePath, content }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async readAppDataFile(filePath: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_app_data_file", { filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async readFileContent(filePath: string, projectRoot: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_file_content", { filePath, projectRoot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async writeFileContent(filePath: string, content: string, projectRoot: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("write_file_content", { filePath, content, projectRoot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createDirectory(path: string, projectRoot: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_directory", { path, projectRoot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if a file path is within the project directory
 * 
 * # Arguments
 * * `file_path` - The absolute path to check
 * * `project_path` - The absolute path to the project root
 * 
 * # Returns
 * True if the file is within the project, false otherwise
 */
async isPathInProject(filePath: string, projectPath: string) : Promise<boolean> {
    return await TAURI_INVOKE("is_path_in_project", { filePath, projectPath });
},
/**
 * Gets the relative path of a file from the project root
 * 
 * # Arguments
 * * `file_path` - The absolute path to the file
 * * `project_path` - The absolute path to the project root
 * 
 * # Returns
 * The relative path from project root, or an error if the file is not in the project
 */
async getRelativePath(filePath: string, projectPath: string, currentFilePath: string, useRelativePaths: boolean) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_relative_path", { filePath, projectPath, currentFilePath, useRelativePaths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Resolves an image path from markdown to an absolute filesystem path
 * 
 * Handles both absolute paths (starting with /) and relative paths (starting with ./ or ../)
 * For absolute paths: treats them as relative to project root
 * For relative paths: resolves relative to the current file's directory
 * 
 * # Arguments
 * * `image_path` - The image path from markdown (e.g., "/src/assets/image.png" or "./image.png")
 * * `project_root` - The absolute path to the project root directory
 * * `current_file_path` - Optional absolute path to the current file being edited
 * 
 * # Returns
 * The validated absolute filesystem path that can be used with convertFileSrc
 */
async resolveImagePath(imagePath: string, projectRoot: string, currentFilePath: string | null) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resolve_image_path", { imagePath, projectRoot, currentFilePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async selectProjectFolder() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("select_project_folder") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async scanProject(projectPath: string) : Promise<Result<Collection[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("scan_project", { projectPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async scanProjectWithContentDir(projectPath: string, contentDirectory: string | null) : Promise<Result<Collection[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("scan_project_with_content_dir", { projectPath, contentDirectory }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async scanCollectionFiles(collectionPath: string) : Promise<Result<FileEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("scan_collection_files", { collectionPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loadFileBasedCollection(projectPath: string, collectionName: string) : Promise<Result<FileEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_file_based_collection", { projectPath, collectionName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async readJsonSchema(projectPath: string, collectionName: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_json_schema", { projectPath, collectionName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Scan a single directory (non-recursive) for subdirectories and markdown/mdx files
 */
async scanDirectory(directoryPath: string, collectionName: string, collectionRoot: string) : Promise<Result<DirectoryScanResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("scan_directory", { directoryPath, collectionName, collectionRoot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Count all markdown/mdx files recursively in a collection
 */
async countCollectionFilesRecursive(collectionPath: string) : Promise<Result<number, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("count_collection_files_recursive", { collectionPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async startWatchingProject(projectPath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_watching_project", { projectPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async startWatchingProjectWithContentDir(projectPath: string, contentDirectory: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_watching_project_with_content_dir", { projectPath, contentDirectory }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopWatchingProject(projectPath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_watching_project", { projectPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Opens the preferences folder in the system's default file manager
 */
async openPreferencesFolder() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_preferences_folder") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Resets all preferences by deleting the app data directory and restarting the app
 */
async resetAllPreferences() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_all_preferences") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAppVersion() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_version") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getPlatformInfo() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_platform_info") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAppInfo() : Promise<Result<AppInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_info") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openPathInIde(ideCommand: string, filePath: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_path_in_ide", { ideCommand, filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableIdes() : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_ides") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async scanMdxComponents(projectPath: string, mdxDirectory: string | null) : Promise<Result<MdxComponent[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("scan_mdx_components", { projectPath, mdxDirectory }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async copyTextToClipboard(text: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("copy_text_to_clipboard", { text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AppInfo = { version: string; platform: string }
export type Collection = { name: string; path: string; complete_schema?: string | null }
export type ComponentFramework = "astro" | "react" | "vue" | "svelte"
export type DirectoryInfo = { name: string; relative_path: string; full_path: string }
export type DirectoryScanResult = { subdirectories: DirectoryInfo[]; files: FileEntry[] }
export type FileEntry = { id: string; path: string; name: string; extension: string; isDraft: boolean; collection: string; last_modified: number | null; frontmatter: Partial<{ [key in string]: JsonValue }> | null }
export type JsonValue = null | boolean | number | string | JsonValue[] | Partial<{ [key in string]: JsonValue }>
export type MarkdownContent = { frontmatter: Partial<{ [key in string]: JsonValue }>; content: string; raw_frontmatter: string; imports: string }
export type MdxComponent = { name: string; file_path: string; props: PropInfo[]; has_slot: boolean; description: string | null; framework: ComponentFramework }
export type PropInfo = { name: string; prop_type: string; is_optional: boolean; default_value: string | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
